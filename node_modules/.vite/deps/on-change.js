import {
  __commonJS
} from "./chunk-5WWUZCGV.js";

// node_modules/on-change/lib/constants.js
var require_constants = __commonJS({
  "node_modules/on-change/lib/constants.js"(exports, module) {
    module.exports = {
      PATH_SEPARATOR: ".",
      TARGET: Symbol("target"),
      UNSUBSCRIBE: Symbol("unsubscribe")
    };
  }
});

// node_modules/on-change/lib/is-builtin.js
var require_is_builtin = __commonJS({
  "node_modules/on-change/lib/is-builtin.js"(exports, module) {
    "use strict";
    var isBuiltin = {
      withMutableMethods: (value) => {
        return value instanceof Date || value instanceof Set || value instanceof Map || value instanceof WeakSet || value instanceof WeakMap;
      },
      withoutMutableMethods: (value) => (typeof value === "object" ? value === null : typeof value !== "function") || value instanceof RegExp
    };
    module.exports = isBuiltin;
  }
});

// node_modules/on-change/lib/is-array.js
var require_is_array = __commonJS({
  "node_modules/on-change/lib/is-array.js"(exports, module) {
    "use strict";
    module.exports = Array.isArray;
  }
});

// node_modules/on-change/lib/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/on-change/lib/is-symbol.js"(exports, module) {
    "use strict";
    module.exports = (value) => typeof value === "symbol";
  }
});

// node_modules/on-change/lib/path.js
var require_path = __commonJS({
  "node_modules/on-change/lib/path.js"(exports, module) {
    "use strict";
    var { PATH_SEPARATOR } = require_constants();
    var isArray = require_is_array();
    var isSymbol = require_is_symbol();
    module.exports = {
      after: (path, subPath) => {
        if (isArray(path)) {
          return path.slice(subPath.length);
        }
        if (subPath === "") {
          return path;
        }
        return path.slice(subPath.length + 1);
      },
      concat: (path, key) => {
        if (isArray(path)) {
          path = path.slice();
          if (key) {
            path.push(key);
          }
          return path;
        }
        if (key && key.toString !== void 0) {
          if (path !== "") {
            path += PATH_SEPARATOR;
          }
          if (isSymbol(key)) {
            return path + key.toString();
          }
          return path + key;
        }
        return path;
      },
      initial: (path) => {
        if (isArray(path)) {
          return path.slice(0, -1);
        }
        if (path === "") {
          return path;
        }
        const index = path.lastIndexOf(PATH_SEPARATOR);
        if (index === -1) {
          return "";
        }
        return path.slice(0, index);
      },
      last: (path) => {
        if (isArray(path)) {
          return path[path.length - 1] || "";
        }
        if (path === "") {
          return path;
        }
        const index = path.lastIndexOf(PATH_SEPARATOR);
        if (index === -1) {
          return path;
        }
        return path.slice(index + 1);
      },
      walk: (path, callback) => {
        if (isArray(path)) {
          path.forEach((key) => callback(key));
        } else if (path !== "") {
          let position = 0;
          let index = path.indexOf(PATH_SEPARATOR);
          if (index === -1) {
            callback(path);
          } else {
            while (position < path.length) {
              if (index === -1) {
                index = path.length;
              }
              callback(path.slice(position, index));
              position = index + 1;
              index = path.indexOf(PATH_SEPARATOR, position);
            }
          }
        }
      }
    };
  }
});

// node_modules/on-change/lib/is-iterator.js
var require_is_iterator = __commonJS({
  "node_modules/on-change/lib/is-iterator.js"(exports, module) {
    "use strict";
    module.exports = (value) => typeof value === "object" && typeof value.next === "function";
  }
});

// node_modules/on-change/lib/wrap-iterator.js
var require_wrap_iterator = __commonJS({
  "node_modules/on-change/lib/wrap-iterator.js"(exports, module) {
    "use strict";
    var { TARGET } = require_constants();
    module.exports = (iterator, target, thisArg, applyPath, prepareValue) => {
      const originalNext = iterator.next;
      if (target.name === "entries") {
        iterator.next = function() {
          const result = originalNext.call(this);
          if (result.done === false) {
            result.value[0] = prepareValue(
              result.value[0],
              target,
              result.value[0],
              applyPath
            );
            result.value[1] = prepareValue(
              result.value[1],
              target,
              result.value[0],
              applyPath
            );
          }
          return result;
        };
      } else if (target.name === "values") {
        const keyIterator = thisArg[TARGET].keys();
        iterator.next = function() {
          const result = originalNext.call(this);
          if (result.done === false) {
            result.value = prepareValue(
              result.value,
              target,
              keyIterator.next().value,
              applyPath
            );
          }
          return result;
        };
      } else {
        iterator.next = function() {
          const result = originalNext.call(this);
          if (result.done === false) {
            result.value = prepareValue(
              result.value,
              target,
              result.value,
              applyPath
            );
          }
          return result;
        };
      }
      return iterator;
    };
  }
});

// node_modules/on-change/lib/ignore-property.js
var require_ignore_property = __commonJS({
  "node_modules/on-change/lib/ignore-property.js"(exports, module) {
    "use strict";
    var isSymbol = require_is_symbol();
    module.exports = (cache, options, property) => {
      return cache.isUnsubscribed || options.ignoreSymbols && isSymbol(property) || options.ignoreUnderscores && property.charAt(0) === "_" || "ignoreKeys" in options && options.ignoreKeys.includes(property);
    };
  }
});

// node_modules/on-change/lib/cache.js
var require_cache = __commonJS({
  "node_modules/on-change/lib/cache.js"(exports, module) {
    "use strict";
    var path = require_path();
    var Cache = class {
      constructor(equals) {
        this._equals = equals;
        this._proxyCache = /* @__PURE__ */ new WeakMap();
        this._pathCache = /* @__PURE__ */ new WeakMap();
        this.isUnsubscribed = false;
      }
      _getDescriptorCache() {
        if (this._descriptorCache === void 0) {
          this._descriptorCache = /* @__PURE__ */ new WeakMap();
        }
        return this._descriptorCache;
      }
      _getProperties(target) {
        const descriptorCache = this._getDescriptorCache();
        let properties = descriptorCache.get(target);
        if (properties === void 0) {
          properties = {};
          descriptorCache.set(target, properties);
        }
        return properties;
      }
      _getOwnPropertyDescriptor(target, property) {
        if (this.isUnsubscribed) {
          return Reflect.getOwnPropertyDescriptor(target, property);
        }
        const properties = this._getProperties(target);
        let descriptor = properties[property];
        if (descriptor === void 0) {
          descriptor = Reflect.getOwnPropertyDescriptor(target, property);
          properties[property] = descriptor;
        }
        return descriptor;
      }
      getProxy(target, path2, handler, proxyTarget) {
        if (this.isUnsubscribed) {
          return target;
        }
        this._pathCache.set(target, path2);
        let proxy = this._proxyCache.get(target);
        if (proxy === void 0) {
          proxy = target[proxyTarget] === void 0 ? new Proxy(target, handler) : target;
          this._proxyCache.set(target, proxy);
        }
        return proxy;
      }
      getPath(target) {
        return this.isUnsubscribed ? void 0 : this._pathCache.get(target);
      }
      isDetached(target, object) {
        path.walk(this.getPath(target), (key) => {
          if (object) {
            object = object[key];
          }
        });
        return !Object.is(target, object);
      }
      defineProperty(target, property, descriptor) {
        if (!Reflect.defineProperty(target, property, descriptor)) {
          return false;
        }
        if (!this.isUnsubscribed) {
          this._getProperties(target)[property] = descriptor;
        }
        return true;
      }
      setProperty(target, property, value, receiver, previous) {
        if (!this._equals(previous, value) || !(property in target)) {
          const descriptor = this._getOwnPropertyDescriptor(target, property);
          if (descriptor !== void 0 && "set" in descriptor) {
            return Reflect.set(target, property, value, receiver);
          }
          return Reflect.set(target, property, value);
        }
        return true;
      }
      deleteProperty(target, property, previous) {
        if (Reflect.deleteProperty(target, property)) {
          if (!this.isUnsubscribed) {
            const properties = this._getDescriptorCache().get(target);
            if (properties) {
              delete properties[property];
              this._pathCache.delete(previous);
            }
          }
          return true;
        }
        return false;
      }
      isSameDescriptor(a, target, property) {
        const b = this._getOwnPropertyDescriptor(target, property);
        return a !== void 0 && b !== void 0 && Object.is(a.value, b.value) && (a.writable || false) === (b.writable || false) && (a.enumerable || false) === (b.enumerable || false) && (a.configurable || false) === (b.configurable || false) && a.get === b.get && a.set === b.set;
      }
      isGetInvariant(target, property) {
        const descriptor = this._getOwnPropertyDescriptor(target, property);
        return descriptor !== void 0 && descriptor.configurable !== true && descriptor.writable !== true;
      }
      unsubscribe() {
        this._descriptorCache = null;
        this._pathCache = null;
        this._proxyCache = null;
        this.isUnsubscribed = true;
      }
    };
    module.exports = Cache;
  }
});

// node_modules/on-change/lib/is-object.js
var require_is_object = __commonJS({
  "node_modules/on-change/lib/is-object.js"(exports, module) {
    "use strict";
    module.exports = (value) => toString.call(value) === "[object Object]";
  }
});

// node_modules/on-change/lib/smart-clone.js
var require_smart_clone = __commonJS({
  "node_modules/on-change/lib/smart-clone.js"(exports, module) {
    "use strict";
    var path = require_path();
    var isArray = require_is_array();
    var isBuiltin = require_is_builtin();
    var isObject = require_is_object();
    var certainChange = () => true;
    var shallowEqualArrays = (clone, value) => {
      return clone.length !== value.length || clone.some((item, index) => value[index] !== item);
    };
    var shallowEqualSets = (clone, value) => {
      if (clone.size !== value.size) {
        return true;
      }
      for (const element of clone) {
        if (!value.has(element)) {
          return true;
        }
      }
      return false;
    };
    var shallowEqualMaps = (clone, value) => {
      if (clone.size !== value.size) {
        return true;
      }
      let bValue;
      for (const [key, aValue] of clone) {
        bValue = value.get(key);
        if (bValue !== aValue || bValue === void 0 && !value.has(key)) {
          return true;
        }
      }
      return false;
    };
    var IMMUTABLE_OBJECT_METHODS = /* @__PURE__ */ new Set([
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf"
    ]);
    var IMMUTABLE_ARRAY_METHODS = /* @__PURE__ */ new Set([
      "concat",
      "includes",
      "indexOf",
      "join",
      "keys",
      "lastIndexOf"
    ]);
    var IMMUTABLE_SET_METHODS = /* @__PURE__ */ new Set([
      "has",
      "toString"
    ]);
    var IMMUTABLE_MAP_METHODS = new Set([...IMMUTABLE_SET_METHODS].concat(["get"]));
    var SHALLOW_MUTABLE_ARRAY_METHODS = {
      push: certainChange,
      pop: certainChange,
      shift: certainChange,
      unshift: certainChange,
      copyWithin: shallowEqualArrays,
      reverse: shallowEqualArrays,
      sort: shallowEqualArrays,
      splice: shallowEqualArrays,
      flat: shallowEqualArrays,
      fill: shallowEqualArrays
    };
    var SHALLOW_MUTABLE_SET_METHODS = {
      add: shallowEqualSets,
      clear: shallowEqualSets,
      delete: shallowEqualSets
    };
    var COLLECTION_ITERATOR_METHODS = [
      "keys",
      "values",
      "entries"
    ];
    var SHALLOW_MUTABLE_MAP_METHODS = {
      set: shallowEqualMaps,
      clear: shallowEqualMaps,
      delete: shallowEqualMaps
    };
    var HANDLED_ARRAY_METHODS = new Set([...IMMUTABLE_OBJECT_METHODS].concat([...IMMUTABLE_ARRAY_METHODS]).concat(Object.keys(SHALLOW_MUTABLE_ARRAY_METHODS)));
    var HANDLED_SET_METHODS = new Set([...IMMUTABLE_SET_METHODS].concat(Object.keys(SHALLOW_MUTABLE_SET_METHODS)).concat(COLLECTION_ITERATOR_METHODS));
    var HANDLED_MAP_METHODS = new Set([...IMMUTABLE_MAP_METHODS].concat(Object.keys(SHALLOW_MUTABLE_MAP_METHODS)).concat(COLLECTION_ITERATOR_METHODS));
    var Clone = class {
      constructor(value, path2, argumentsList) {
        this._path = path2;
        this._isChanged = false;
        this._clonedCache = /* @__PURE__ */ new Set();
        if (value instanceof WeakSet) {
          this._weakValue = value.has(argumentsList[0]);
        } else if (value instanceof WeakMap) {
          this._weakValue = value.get(argumentsList[0]);
        } else {
          this.clone = path2 === void 0 ? value : this._shallowClone(value);
        }
      }
      _shallowClone(value) {
        let clone;
        if (isObject(value)) {
          clone = { ...value };
        } else if (isArray(value)) {
          clone = [...value];
        } else if (value instanceof Date) {
          clone = new Date(value);
        } else if (value instanceof Set) {
          clone = new Set(value);
        } else if (value instanceof Map) {
          clone = new Map(value);
        }
        this._clonedCache.add(clone);
        return clone;
      }
      preferredThisArg(target, thisArg, thisProxyTarget) {
        const { name } = target;
        if (SmartClone.isHandledMethod(thisProxyTarget, name)) {
          if (isArray(thisProxyTarget)) {
            this._onIsChanged = SHALLOW_MUTABLE_ARRAY_METHODS[name];
          } else if (thisProxyTarget instanceof Set) {
            this._onIsChanged = SHALLOW_MUTABLE_SET_METHODS[name];
          } else if (thisProxyTarget instanceof Map) {
            this._onIsChanged = SHALLOW_MUTABLE_MAP_METHODS[name];
          }
          return thisProxyTarget;
        }
        return thisArg;
      }
      update(fullPath, property, value) {
        if (value !== void 0 && property !== "length") {
          let object = this.clone;
          path.walk(path.after(fullPath, this._path), (key) => {
            if (!this._clonedCache.has(object[key])) {
              object[key] = this._shallowClone(object[key]);
            }
            object = object[key];
          });
          object[property] = value;
        }
        this._isChanged = true;
      }
      isChanged(value, equals, argumentsList) {
        if (value instanceof Date) {
          return !equals(this.clone.valueOf(), value.valueOf());
        }
        if (value instanceof WeakSet) {
          return this._weakValue !== value.has(argumentsList[0]);
        }
        if (value instanceof WeakMap) {
          return this._weakValue !== value.get(argumentsList[0]);
        }
        return this._onIsChanged === void 0 ? this._isChanged : this._onIsChanged(this.clone, value);
      }
    };
    var SmartClone = class {
      constructor() {
        this.stack = [];
      }
      static isHandledType(value) {
        return isObject(value) || isArray(value) || isBuiltin.withMutableMethods(value);
      }
      static isHandledMethod(target, name) {
        if (isObject(target)) {
          return IMMUTABLE_OBJECT_METHODS.has(name);
        }
        if (isArray(target)) {
          return HANDLED_ARRAY_METHODS.has(name);
        }
        if (target instanceof Set) {
          return HANDLED_SET_METHODS.has(name);
        }
        if (target instanceof Map) {
          return HANDLED_MAP_METHODS.has(name);
        }
        return isBuiltin.withMutableMethods(target);
      }
      get isCloning() {
        return this.stack.length !== 0;
      }
      start(value, path2, argumentsList) {
        this.stack.push(new Clone(value, path2, argumentsList));
      }
      update(fullPath, property, value) {
        this.stack[this.stack.length - 1].update(fullPath, property, value);
      }
      preferredThisArg(target, thisArg, thisProxyTarget) {
        return this.stack[this.stack.length - 1].preferredThisArg(target, thisArg, thisProxyTarget);
      }
      isChanged(isMutable, value, equals, argumentsList) {
        return this.stack[this.stack.length - 1].isChanged(isMutable, value, equals, argumentsList);
      }
      stop() {
        return this.stack.pop().clone;
      }
    };
    module.exports = SmartClone;
  }
});

// node_modules/on-change/index.js
var require_on_change = __commonJS({
  "node_modules/on-change/index.js"(exports, module) {
    var { TARGET, UNSUBSCRIBE } = require_constants();
    var isBuiltin = require_is_builtin();
    var path = require_path();
    var isSymbol = require_is_symbol();
    var isIterator = require_is_iterator();
    var wrapIterator = require_wrap_iterator();
    var ignoreProperty = require_ignore_property();
    var Cache = require_cache();
    var SmartClone = require_smart_clone();
    var defaultOptions = {
      equals: Object.is,
      isShallow: false,
      pathAsArray: false,
      ignoreSymbols: false,
      ignoreUnderscores: false,
      ignoreDetached: false
    };
    var onChange = (object, onChange2, options = {}) => {
      options = {
        ...defaultOptions,
        ...options
      };
      const proxyTarget = Symbol("ProxyTarget");
      const { equals, isShallow, ignoreDetached } = options;
      const cache = new Cache(equals);
      const smartClone = new SmartClone();
      const handleChangeOnTarget = (target, property, previous, value) => {
        if (!ignoreProperty(cache, options, property) && !(ignoreDetached && cache.isDetached(target, object))) {
          handleChange(cache.getPath(target), property, previous, value);
        }
      };
      const handleChange = (changePath, property, previous, value, name) => {
        if (smartClone.isCloning) {
          smartClone.update(changePath, property, previous);
        } else {
          onChange2(path.concat(changePath, property), value, previous, name);
        }
      };
      const getProxyTarget = (value) => {
        if (value) {
          return value[proxyTarget] || value;
        }
        return value;
      };
      const prepareValue = (value, target, property, basePath) => {
        if (isBuiltin.withoutMutableMethods(value) || property === "constructor" || isShallow && !SmartClone.isHandledMethod(target, property) || ignoreProperty(cache, options, property) || cache.isGetInvariant(target, property) || ignoreDetached && cache.isDetached(target, object)) {
          return value;
        }
        if (basePath === void 0) {
          basePath = cache.getPath(target);
        }
        return cache.getProxy(value, path.concat(basePath, property), handler, proxyTarget);
      };
      const handler = {
        get(target, property, receiver) {
          if (isSymbol(property)) {
            if (property === proxyTarget || property === TARGET) {
              return target;
            }
            if (property === UNSUBSCRIBE && !cache.isUnsubscribed && cache.getPath(target).length === 0) {
              cache.unsubscribe();
              return target;
            }
          }
          const value = isBuiltin.withMutableMethods(target) ? Reflect.get(target, property) : Reflect.get(target, property, receiver);
          return prepareValue(value, target, property);
        },
        set(target, property, value, receiver) {
          value = getProxyTarget(value);
          const reflectTarget = target[proxyTarget] || target;
          const previous = reflectTarget[property];
          const hasProperty = property in target;
          if (cache.setProperty(reflectTarget, property, value, receiver, previous)) {
            if (!equals(previous, value) || !hasProperty) {
              handleChangeOnTarget(target, property, previous, value);
            }
            return true;
          }
          return false;
        },
        defineProperty(target, property, descriptor) {
          if (!cache.isSameDescriptor(descriptor, target, property)) {
            if (!cache.defineProperty(target, property, descriptor)) {
              return false;
            }
            handleChangeOnTarget(target, property, void 0, descriptor.value);
          }
          return true;
        },
        deleteProperty(target, property) {
          if (!Reflect.has(target, property)) {
            return true;
          }
          const previous = Reflect.get(target, property);
          if (cache.deleteProperty(target, property, previous)) {
            handleChangeOnTarget(target, property, previous);
            return true;
          }
          return false;
        },
        apply(target, thisArg, argumentsList) {
          const thisProxyTarget = thisArg[proxyTarget] || thisArg;
          if (cache.isUnsubscribed) {
            return Reflect.apply(target, thisProxyTarget, argumentsList);
          }
          if (SmartClone.isHandledType(thisProxyTarget)) {
            const applyPath = path.initial(cache.getPath(target));
            const isHandledMethod = SmartClone.isHandledMethod(thisProxyTarget, target.name);
            smartClone.start(thisProxyTarget, applyPath, argumentsList);
            const result = Reflect.apply(
              target,
              smartClone.preferredThisArg(target, thisArg, thisProxyTarget),
              isHandledMethod ? argumentsList.map((argument) => getProxyTarget(argument)) : argumentsList
            );
            const isChanged = smartClone.isChanged(thisProxyTarget, equals, argumentsList);
            const clone = smartClone.stop();
            if (isChanged) {
              if (smartClone.isCloning) {
                handleChange(path.initial(applyPath), path.last(applyPath), clone, thisProxyTarget, target.name);
              } else {
                handleChange(applyPath, "", clone, thisProxyTarget, target.name);
              }
            }
            if ((thisArg instanceof Map || thisArg instanceof Set) && isIterator(result)) {
              return wrapIterator(result, target, thisArg, applyPath, prepareValue);
            }
            return SmartClone.isHandledType(result) && isHandledMethod ? cache.getProxy(result, applyPath, handler, proxyTarget) : result;
          }
          return Reflect.apply(target, thisArg, argumentsList);
        }
      };
      const proxy = cache.getProxy(object, options.pathAsArray ? [] : "", handler);
      onChange2 = onChange2.bind(proxy);
      return proxy;
    };
    onChange.target = (proxy) => proxy[TARGET] || proxy;
    onChange.unsubscribe = (proxy) => proxy[UNSUBSCRIBE] || proxy;
    module.exports = onChange;
  }
});
export default require_on_change();
//# sourceMappingURL=on-change.js.map
